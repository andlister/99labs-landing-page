<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Security & IT Landscape — Card View</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700;900&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0b1016;--panel:#121823;--ink:#e7eef7;--muted:#9bb0c8;--line:#2a3a50;--chip:#172233;
      --c1:#5aa9ff;--c2:#7bd389;--c3:#ffb86b;--c4:#de6fff;--c5:#ff6f91;--c6:#6ef2ff;
      --labelw: 86px;
    }
    /* Light theme overrides */
    :root.light{
      --bg:#ffffff;
      --panel:#ffffff;
      --ink:#0b1016;
      --muted:#4a5568;
      --line:#d8e1ea;
      --chip:#f3f7fb;
      --c1:#1e88e5;--c2:#2e7d32;--c3:#ef6c00;--c4:#8e24aa;--c5:#d81b60;--c6:#00838f;
      --labelw: 86px;
    }
    .themeToggle{position:fixed;right:16px;top:16px;z-index:9999;background:var(--panel);color:var(--ink);border:1px solid var(--line);border-radius:999px;padding:8px 12px;font-size:12px;cursor:pointer;box-shadow:0 1px 2px rgba(0,0,0,.06)}
    .themeToggle:hover{box-shadow:0 2px 6px rgba(0,0,0,.08)}
    *{box-sizing:border-box}
    body{margin:0;font-family:'Lato', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--ink)}
    .wrap{max-width:100%;margin:16px auto;padding:0 24px}
    h1{font-size:28px;margin:12px 0 6px;font-weight:900;letter-spacing:.2px}
    h2{font-size:20px;margin:28px 0 12px;color:var(--ink);font-weight:700;letter-spacing:.2px}
    p.lead{color:var(--muted);margin:0 0 16px}

    /* Card wall */
    .wall{display:grid;grid-template-columns:repeat( auto-fill, minmax(320px, 1fr) );gap:14px}
    .card{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:16px 16px 10px}
    .card{position:relative}
    .platform{box-shadow:none}
    .toolbar{position:static;margin:8px 0 16px;display:flex;gap:8px;flex-wrap:wrap}
    .btn{background:var(--panel);color:var(--ink);border:1px solid var(--line);border-radius:999px;padding:6px 10px;font-size:12px;cursor:pointer}
    .btn.active{outline:2px solid #FFA500}

    /* Filter chip bars */
    .filters{display:flex;flex-wrap:wrap;gap:8px;margin:6px 0 16px}
    .fgroup{display:flex;align-items:center;gap:8px;flex-wrap:wrap;flex:1 1 100%}
    .capGroup{position:relative;align-items:flex-start;flex-basis:100%}
    .flabel{
      font-size:12px;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.06em;
      margin-right:6px;
      display:block;
      width:100%;
    }
    .fchip{background:var(--panel);color:var(--ink);border:1px solid var(--line);border-radius:999px;padding:6px 10px;font-size:12px;cursor:pointer}
    .fchip.on{outline:2px solid #3eb5c1}
    .fchip.on.cust{outline:2px solid #a78bfa}
    .fchip.all.on{outline:2px solid #3eb5c1}
    .fchip.all.on.cust{outline:2px solid #a78bfa}
    /* Layer filter chips (orange outline) */
    .fchip.on.layer{ outline:2px solid #FFA500 }
    .fchip.all.on.layer{ outline:2px solid #FFA500 }
    /* Delivery filter chips (blue outline) */
    .fchip.on.delivery{ outline:2px solid #5aa9ff }
    .fchip.all.on.delivery{ outline:2px solid #5aa9ff }
    /* Channels filter chips (pink outline) */
    .fchip.on.channel{ outline:2px solid #ff6f91 }
    .fchip.all.on.channel{ outline:2px solid #ff6f91 }

    .capTopRow{display:flex;flex-wrap:wrap;gap:8px;align-items:center;position:relative}
    .capActiveList{display:flex;flex-wrap:wrap;gap:8px}
    .capMoreBtn{position:relative;padding-right:28px}
    .capMoreBtn::after{content:"";position:absolute;right:10px;top:50%;width:6px;height:6px;border-right:1px solid currentColor;border-bottom:1px solid currentColor;transform:translateY(-50%) rotate(45deg);opacity:.6}
    .capMoreBtn[aria-expanded="true"]::after{transform:translateY(-20%) rotate(225deg)}

    .capPopover{position:absolute;top:calc(100% + 8px);left:0;background:var(--bg);border:1px solid var(--line);border-radius:12px;box-shadow:0 18px 36px rgba(15,23,42,0.35);padding:16px;min-width:260px;max-width:320px;max-height:340px;overflow:auto;z-index:90}
    .capPopover.hidden{display:none}
    .capPopover:focus{outline:none}
    .capSearch{width:100%;padding:8px 10px;border-radius:8px;border:1px solid var(--line);background:var(--panel);color:var(--ink);font-size:13px;margin-bottom:12px}
    .capList{display:flex;flex-direction:column;gap:6px}
    .capOption{display:flex;align-items:center;gap:8px;padding:4px 6px;border-radius:6px;font-size:12px;cursor:pointer}
    .capOption input{width:14px;height:14px;pointer-events:none}
    .capOption:hover{background:rgba(62,181,193,0.08)}
    .capActions{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-top:12px}
    .capActions button{flex:1;background:var(--panel);border:1px solid var(--line);border-radius:999px;padding:6px 10px;font-size:12px;color:var(--ink);cursor:pointer}
    .capActions button.primary{border-color:#3eb5c1}

    .card h3{margin:0 0 10px;font-size:16px}
    .card h3 a{color:inherit;text-decoration:none} .card h3 a:hover{text-decoration:underline}
    .badges{display:flex;flex-wrap:wrap;gap:6px;margin:4px 0;align-items:center}
    .b{background:var(--chip);color:var(--ink);border:1px solid var(--line);padding:4px 10px;border-radius:999px;font-size:12px;white-space:nowrap}
    .muted{color:var(--muted);font-size:13px;margin-top:12px;margin-bottom:0;padding-top:8px;border-top:none}

    /* Layer pill styling: muted orange outlines; primary bright orange, no fill */
    .layersRow .b{ background:transparent; border:2px solid rgba(255,165,0,0.50); opacity:1 }
    .layersRow .b.primaryLayer{ border:2px solid #FFA500 }
    /* Capabilities (teal) and Customers (lavender) outlines */
    .categoriesRow .b{ background:transparent; border:2px solid rgba(62,181,193,0.50); opacity:1 }
    .customersRow  .b{ background:transparent; border:2px solid rgba(167,139,250,0.50); opacity:1 }
    .modelRow .b{ background:transparent; border:2px solid rgba(90,169,255,0.50); opacity:1 }
    .channelsRow .b{ background:transparent; border:2px solid rgba(255,111,145,0.50); opacity:1 }
    .categoriesRow .b.primaryCap{ border:2px solid #3eb5c1 }
    .customersRow  .b.primaryCust{ border:2px solid #a78bfa }
    .modelRow .b.primaryDelivery{ border:2px solid #5aa9ff }
    .channelsRow .b.primaryChannel{ border:2px solid #ff6f91 }

    /* Labeled chip rows (labels above, pills below) */
    .layersRow::before,
    .categoriesRow::before,
    .customersRow::before,
    .channelsRow::before,
    .modelRow::before{
      content:"";
      display:block;
      width:100%;
      margin:0 0 6px 0;
      font-size:10px;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.06em;
      opacity:.9;
    }
    .layersRow::before{ content:"Layers"; }
    .categoriesRow::before{ content:"Capabilities"; }
    .customersRow::before{ content:"Customers"; }
    .channelsRow::before{ content:"Channels"; }
    .modelRow::before{ content:"Delivery"; }

    /* Unified spacing (no separators) */
    .layersRow,
    .customersRow,
    .categoriesRow,
    .modelRow{
      margin-bottom:16px;
      padding-bottom:8px;
      border-bottom:none;
    }

    /* Group sections */
    .group{margin:18px 0 8px;padding-top:12px}
    .groupTitle{font-size:14px;color:var(--muted);text-transform:uppercase;letter-spacing:.08em;margin:0 0 8px}

    /* Customer/Industry grid (kept from earlier in case you use it later) */
    .grid{display:grid;grid-template-columns:260px 1fr;gap:0;border:1px solid var(--line);border-radius:10px;overflow:hidden}
    .colL,.colR{background:var(--panel);border-bottom:1px solid var(--line)}
    .colL{padding:12px 14px;font-weight:700;border-right:1px solid var(--line);display:flex;align-items:center}
    .colR{padding:12px 14px}
    .chips{display:flex;flex-wrap:wrap;gap:8px}
    .chip{display:inline-flex;align-items:center;justify-content:center;background:var(--chip);padding:6px 12px;border-radius:999px;border:1px solid var(--line);font-size:13px;white-space:nowrap}
    .last{border-bottom:none}

    @media (max-width:900px){
      .grid{grid-template-columns:1fr}
      .colL{border-right:none}
    }
  </style>
</head>
<body>
  <button class="themeToggle" id="themeToggle" aria-label="Toggle theme">Toggle theme</button>
  <div class="wrap">
    <h1>Security & IT Landscape</h1>
    <p class="lead"></p>

    <div class="toolbar">
      <div class="fgroup" id="layerFilters" style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
        <span class="flabel">Layers:</span>
        <button class="btn" id="btnAll">Show all</button>
        <button class="btn" id="btnPlatforms">All-in-one (≥4 layers)</button>
        <button class="btn" id="btnSpanners">Spanners (≥3 layers)</button>
        <!-- layer pills appended dynamically -->
      </div>
    </div>

    <div class="filters">
      <div class="fgroup" id="custFilters"><span class="flabel">Customers:</span></div>
      <div class="fgroup" id="channelFilters"><span class="flabel">Channels:</span></div>
      <div class="fgroup" id="deliveryFilters"><span class="flabel">Delivery:</span></div>
      <div class="fgroup capGroup" id="capFilters">
        <div class="flabel">Capabilities:</div>
      </div>
    </div>

    <!-- Predeclared groups (new/unknown primaryLayer groups will be created dynamically at the end) -->
    <div class="group">
      <p class="groupTitle">Identity</p>
      <div class="wall" id="wall-Identity"></div>
    </div>

    <div class="group">
      <p class="groupTitle">Device / IT Operations</p>
      <div class="wall" id="wall-Device / IT Operations"></div>
    </div>

    <div class="group">
      <p class="groupTitle">Cloud / Tenant</p>
      <div class="wall" id="wall-Cloud / Tenant"></div>
    </div>

    <div class="group">
      <p class="groupTitle">Security</p>
      <div class="wall" id="wall-Security"></div>
    </div>

    <div class="group">
      <p class="groupTitle">Security Operations</p>
      <div class="wall" id="wall-Security Operations"></div>
    </div>

    <div class="group">
      <p class="groupTitle">Compliance</p>
      <div class="wall" id="wall-Compliance"></div>
    </div>
  </div>
</body>
<script>
(async function(){
  // ========= Theme bootstrap =========
  const KEY='theme-preference';
  const params=new URLSearchParams(location.search);
  const qp=params.get('theme');
  const stored=localStorage.getItem(KEY);
  const prefersLight=window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
  let theme='dark';
  if(qp==='light' || qp==='dark'){ theme=qp; localStorage.setItem(KEY, theme); }
  else if(stored){ theme=stored; }
  else if(prefersLight){ theme='light'; }
  document.documentElement.classList.toggle('light', theme==='light');
  const btn=document.getElementById('themeToggle');
  btn.addEventListener('click',()=>{
    const isLight=document.documentElement.classList.toggle('light');
    localStorage.setItem(KEY, isLight?'light':'dark');
  });

  // ========= Data & rendering =========
  async function loadVendors(){
    const res = await fetch('vendors.json', {cache:'no-cache'});
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  }

  let vendors;
  try{
    vendors = await loadVendors();
  }catch(err){
    console.error('Failed to load vendor data:', err);
    alert('Could not load vendor data');
    return;
  }

  // Build LAYERS dynamically from data (show exactly what's in vendors.json)
  let LAYERS = [];
  const allLayerSet = new Set();
  vendors.forEach(v => (v.layers || []).forEach(l => allLayerSet.add(l)));
  LAYERS = Array.from(allLayerSet).sort((a,b)=> a.localeCompare(b));

  // Filters state
  const selectedCaps=new Set();
  const selectedCusts=new Set();
  const selectedDeliveries=new Set();
  const selectedChannels=new Set();
  const selectedLayers=new Set();
  let mode='all'; // all | platforms | spanners

  function el(tag, cls, html){
    const e=document.createElement(tag); if(cls) e.className=cls; if(html!=null) e.innerHTML=html; return e;
  }
  function chip(text){
    const s=el('span','b'); s.textContent=text; return s;
  }

  const byText = s=> s.textContent.trim();
  function intersects(aSet, arr){ if(!aSet.size) return true; for(const v of arr){ if(aSet.has(v)) return true; } return false; }

  // Use vendors.json as source of truth without normalization
  function deliveryTokens(val){
    if(val==null || val==='') return [];
    const toArray = (input)=>{
      if(input==null || input==='') return [];
      if(Array.isArray(input)) return input;
      return [input];
    };
    const tokens=[];
    const seen=new Set();
    toArray(val).forEach(token=>{
      if(token==null) return;
      const t=String(token).trim();
      if(!t) return;
      if(seen.has(t)) return;
      seen.add(t);
      tokens.push(t);
    });
    return tokens;
  }

  function getPrimaryLayer(v){
    const L = v.layers || [];
    if(v.primaryLayer && L.includes(v.primaryLayer)) return v.primaryLayer;
    return L.length ? L[0] : null;
  }

  function buildCard(v){
    const card=el('div','card');

    // Determine primaries (fallback to first array element if explicit primary not set)
    const priLayer = getPrimaryLayer(v);
    const priCustomer = v.primaryCustomer || ((v.customers||[])[0] || null);
    const priCategory = v.primaryCategory || ((v.categories||[])[0] || null);

    const h3=el('h3'); const a=el('a'); a.href=v.url||'#'; a.target='_blank'; a.rel='noopener'; a.textContent=v.name; h3.appendChild(a); card.appendChild(h3);

    // Layers row — show exactly what's in v.layers; mark primary if present
    const layersRow=el('div','badges layersRow');
    const L = v.layers || [];
    L.forEach(lbl=>{
      const pill = chip(lbl);
      if(priLayer === lbl) pill.classList.add('primaryLayer');
      layersRow.appendChild(pill);
    });
    card.appendChild(layersRow);

    // Customers row (mark primary)
    if(v.customers && v.customers.length){
      const cust=el('div','badges customersRow');
      v.customers.forEach((c,idx)=>{
        const ch = chip(c);
        if(priCustomer === c || (!priCustomer && idx===0)) ch.classList.add('primaryCust');
        cust.appendChild(ch);
      });
      card.appendChild(cust);
    }

    // Capabilities row (mark primary)
    if(v.categories && v.categories.length){
      const cats=el('div','badges categoriesRow');
      v.categories.forEach((c,idx)=>{
        const ch = chip(c);
        if(priCategory === c || (!priCategory && idx===0)) ch.classList.add('primaryCap');
        cats.appendChild(ch);
      });
      card.appendChild(cats);
    }

    // Channels row (mark primary = first if not specified)
    const channels = Array.isArray(v.channels) ? v.channels.filter(Boolean) : [];
    const priChannel = channels.length ? channels[0] : null;
    if(channels.length){
      const chRow=el('div','badges channelsRow');
      channels.forEach((c,idx)=>{
        const chp = chip(c);
        if(priChannel === c || (!priChannel && idx===0)) chp.classList.add('primaryChannel');
        chRow.appendChild(chp);
      });
      card.appendChild(chRow);
    }

    // Delivery row
    const deliveries = deliveryTokens(v.delivery);
    const priDelivery = v.primaryDelivery || (deliveries[0] || null);
    if(deliveries.length){
      const modelRow=el('div','badges modelRow');
      deliveries.forEach((d,idx)=>{
        const chp = chip(d);
        if(priDelivery === d || (!priDelivery && idx===0)) chp.classList.add('primaryDelivery');
        modelRow.appendChild(chp);
      });
      card.appendChild(modelRow);
    }

    // Description
    if(v.description){ const p=el('p','muted'); p.textContent=v.description; card.appendChild(p); }

    // Datasets for filters & sorting
    card.dataset.caps = (v.categories||[]).join('|');
    card.dataset.customers = (v.customers||[]).join('|');
    card.dataset.delivery = deliveries.join('|');
    card.dataset.layers = (v.layers || []).join('|');
    card.dataset.primaryLayer = priLayer || '';
    card.dataset.primaryCategory = priCategory || '';
    card.dataset.primaryCustomer = priCustomer || '';
    card.dataset.primaryDelivery = priDelivery || '';
    card.dataset.channels = channels.join('|');
    card.dataset.primaryChannel = priChannel || '';

    return card;
  }

  // Group walls by primaryLayer; create new walls dynamically for unknown values
  const walls={};
  document.querySelectorAll('[id^="wall-"]').forEach(w=>{ walls[w.id.replace('wall-','')] = w; });

  function ensureWall(title){
    if(!title) title = 'Unassigned';
    if(walls[title]) return walls[title];
    const existing = document.getElementById('wall-' + title);
    if(existing){ walls[title] = existing; return existing; }
    const wrap = document.querySelector('.wrap');
    const group = document.createElement('div');
    group.className = 'group';
    const h = document.createElement('p');
    h.className = 'groupTitle';
    h.textContent = title;
    const wall = document.createElement('div');
    wall.className = 'wall';
    wall.id = 'wall-' + title;
    group.appendChild(h);
    group.appendChild(wall);
    wrap.appendChild(group);
    walls[title] = wall;
    return wall;
  }

  vendors.forEach(v=>{
    const key = getPrimaryLayer(v) || 'Unassigned';
    const wall = ensureWall(key);
    wall.appendChild(buildCard(v));
  });

  // Mark platform/spanner by count of layer pills
  document.querySelectorAll('.card').forEach(card=>{
    const count = card.querySelectorAll('.layersRow .b').length;
    card.dataset.span = String(count);
    card.classList.toggle('platform', count>=4);
    card.classList.toggle('spanner', count>=3);
  });

  // Build unique capability, customer, delivery, channel lists
  const allCaps=new Set();
  const capCounts=new Map();
  const allCusts=new Set();
  const allChannels=new Set();
  vendors.forEach(v=>{
    (v.categories||[]).forEach(c=>{
      allCaps.add(c);
      capCounts.set(c, (capCounts.get(c) || 0) + 1);
    });
    (v.customers||[]).forEach(c=>allCusts.add(c));
    (v.channels||[]).forEach(ch=>allChannels.add(ch));
  });

  const capBox=document.getElementById('capFilters');
  const custBox=document.getElementById('custFilters');
  const channelBox=document.getElementById('channelFilters');
  const deliveryBox=document.getElementById('deliveryFilters');
  const layerBox=document.getElementById('layerFilters');
  let capAllBtn, custAllBtn, channelAllBtn, deliveryAllBtn, layerAllBtn;
  
  const capButtons=new Map();
  const capCheckboxes=new Map();
  const capOptionRows=new Map();
  const activeCapButtons=new Map();
  let capMoreBtn, capMoreLabel, capPopover, capSearch, capActiveList;
  let capPopoverOpen=false;

  function makeFchip(text, group){
    const isCust = group==='cust';
    const isDelivery = group==='delivery';
    const isLayer = group==='layer';
    const isChannel = group==='channel';
    const b=document.createElement('button');
    b.type='button';
    b.className = 'fchip' +
      (isCust ? ' cust' : '') +
      (isLayer ? ' layer' : '') +
      (isDelivery ? ' delivery' : '') +
      (isChannel ? ' channel' : '');
    b.textContent=text;
    b.addEventListener('click',()=>{
      let set, allBtn = null;
      if(isCust){ set = selectedCusts; allBtn = custAllBtn; }
      else if(isDelivery){ set = selectedDeliveries; allBtn = deliveryAllBtn; }
      else if(isLayer){ set = selectedLayers; allBtn = layerAllBtn || null; }
      else if(isChannel){ set = selectedChannels; allBtn = channelAllBtn; }
      else return;
      if(set.has(text)) set.delete(text); else set.add(text);
      b.classList.toggle('on');
      if(allBtn){
        if(set.size>0) allBtn.classList.remove('on'); else allBtn.classList.add('on');
      }
      if (isLayer) {
        mode = 'all';
        clearButtons();
      }
      applyFilters();
    });
    return b;
  }

  function makeAllChip(group){
    const isCust = group==='cust';
    const isDelivery = group==='delivery';
    const isLayer = group==='layer';
    const isChannel = group==='channel';
    const b=document.createElement('button');
    b.type='button';
    b.className =
      'fchip all on' +
      (isCust ? ' cust' : '') +
      (isLayer ? ' layer' : '') +
      (isDelivery ? ' delivery' : '') +
      (isChannel ? ' channel' : '');
    b.textContent='Show all';
    b.addEventListener('click',()=>{
      let set, box;
      if(isCust){ set = selectedCusts; box = custBox; }
      else if(isDelivery){ set = selectedDeliveries; box = deliveryBox; }
      else if(isLayer){ set = selectedLayers; box = layerBox; }
      else if(isChannel){ set = selectedChannels; box = channelBox; }
      else return;
      if(!set.size) return;
      set.clear();
      box.querySelectorAll('.fchip').forEach(x=>{ if(!x.classList.contains('all')) x.classList.remove('on'); });
      b.classList.add('on');
      applyFilters();
    });
    return b;
  }
  function makeFchip(text, group){
    const isCust = group==='cust';
    const isDelivery = group==='delivery';
    const isLayer = group==='layer';
    const isChannel = group==='channel';
    const b=document.createElement('button');
    b.type='button';
    b.className = 'fchip' +
      (isCust ? ' cust' : '') +
      (isLayer ? ' layer' : '') +
      (isDelivery ? ' delivery' : '') +
      (isChannel ? ' channel' : '');
    b.textContent=text;
    b.addEventListener('click',()=>{
      let set, allBtn = null;
      if(isCust){ set = selectedCusts; allBtn = custAllBtn; }
      else if(isDelivery){ set = selectedDeliveries; allBtn = deliveryAllBtn; }
      else if(isLayer){ set = selectedLayers; allBtn = layerAllBtn || null; }
      else if(isChannel){ set = selectedChannels; allBtn = channelAllBtn; }
      else return;
      if(set.has(text)) set.delete(text); else set.add(text);
      b.classList.toggle('on');
      if(allBtn){
        if(set.size>0) allBtn.classList.remove('on'); else allBtn.classList.add('on');
      }
      if (isLayer) {
        mode = 'all';
        clearButtons();
      }
      applyFilters();
    });
    return b;
  }

  function setCapSelected(cap, shouldSelect){
    const already = selectedCaps.has(cap);
    if(shouldSelect === already){
      const btn = capButtons.get(cap); if(btn) btn.classList.toggle('on', shouldSelect);
      const cb = capCheckboxes.get(cap); if(cb) cb.checked = shouldSelect;
      return false;
    }
    if(shouldSelect) selectedCaps.add(cap); else selectedCaps.delete(cap);
    const btn = capButtons.get(cap); if(btn) btn.classList.toggle('on', shouldSelect);
    const cb = capCheckboxes.get(cap); if(cb) cb.checked = shouldSelect;
    return true;
  }

  function refreshActiveCapChips(){
    if(!capActiveList) return;
    const extras = Array.from(selectedCaps).filter(cap=> !capButtons.has(cap));
    const keep = new Set(extras);
    activeCapButtons.forEach((btn, cap)=>{
      if(!keep.has(cap)){
        btn.remove();
        activeCapButtons.delete(cap);
      } else {
        btn.classList.add('on');
      }
    });
    extras.forEach(cap=>{
      if(activeCapButtons.has(cap)) return;
      const btn=document.createElement('button');
      btn.type='button';
      btn.className='fchip on';
      btn.textContent=cap;
      btn.title=`Remove ${cap}`;
      btn.addEventListener('click',()=>{
        setCapSelected(cap, false);
        afterCapSelectionChange();
      });
      activeCapButtons.set(cap, btn);
      capActiveList.appendChild(btn);
    });
  }

  function updateCapSummary(){
    if(!capMoreBtn) return;
    const count = selectedCaps.size;
    const label = count ? `More capabilities (${count})` : 'More capabilities';
    if(capMoreLabel) capMoreLabel.textContent = label;
    capMoreBtn.setAttribute('aria-label', count ? `${count} capabilities selected` : 'Show more capabilities');
  }

  function afterCapSelectionChange(){
    if(selectedCaps.size>0) capAllBtn.classList.remove('on');
    else capAllBtn.classList.add('on');
    refreshActiveCapChips();
    updateCapSummary();
    applyFilters();
  }

  function createCapChip(name){
    const btn=document.createElement('button');
    btn.type='button';
    btn.className='fchip';
    btn.textContent=name;
    capButtons.set(name, btn);
    btn.classList.toggle('on', selectedCaps.has(name));
    btn.addEventListener('click',()=>{
      setCapSelected(name, !selectedCaps.has(name));
      afterCapSelectionChange();
    });
    return btn;
  }

  function filterCapOptions(term){
    const query = term.trim().toLowerCase();
    capOptionRows.forEach((row, cap)=>{
      const match = !query || cap.toLowerCase().includes(query);
      row.style.display = match ? '' : 'none';
    });
  }

  function closeCapPopover(){
    if(!capPopoverOpen) return;
    capPopoverOpen=false;
    capPopover.classList.add('hidden');
    capMoreBtn.setAttribute('aria-expanded','false');
    capMoreBtn.focus();
  }

  function openCapPopover(){
    if(capPopoverOpen) return;
    capPopoverOpen=true;
    capPopover.classList.remove('hidden');
    capMoreBtn.setAttribute('aria-expanded','true');
    if(capSearch){
      capSearch.value='';
      filterCapOptions('');
      requestAnimationFrame(()=> capSearch.focus());
    }
  }

  function toggleCapPopover(){
    if(capPopoverOpen) closeCapPopover(); else openCapPopover();
  }

  // Populate UI with All chip, top quick list, and popover
  const capTopRow = el('div','capTopRow');
  capBox.appendChild(capTopRow);

  capAllBtn = document.createElement('button');
  capAllBtn.type='button';
  capAllBtn.className='fchip all on';
  capAllBtn.textContent='Show all';
  capAllBtn.addEventListener('click',()=>{
    if(!selectedCaps.size) return;
    const toClear = Array.from(selectedCaps);
    toClear.forEach(cap=> setCapSelected(cap, false));
    capAllBtn.classList.add('on');
    afterCapSelectionChange();
  });
  capTopRow.appendChild(capAllBtn);

  const capByFrequency = Array.from(allCaps).sort((a,b)=>{
    const diff = (capCounts.get(b) || 0) - (capCounts.get(a) || 0);
    return diff !== 0 ? diff : a.localeCompare(b);
  });
  const topCaps = capByFrequency.slice(0, 6);
  topCaps.forEach(cap=> capTopRow.appendChild(createCapChip(cap)));

  capMoreBtn = document.createElement('button');
  capMoreBtn.type='button';
  capMoreBtn.className='fchip capMoreBtn';
  capMoreLabel=document.createElement('span');
  capMoreLabel.textContent='More capabilities';
  capMoreBtn.appendChild(capMoreLabel);
  capMoreBtn.setAttribute('aria-haspopup','true');
  capMoreBtn.setAttribute('aria-expanded','false');
  capTopRow.appendChild(capMoreBtn);

  capActiveList = el('div','capActiveList');
  capTopRow.appendChild(capActiveList);

  capPopover = el('div','capPopover hidden');
  capPopover.id='capPopover';
  capPopover.tabIndex=-1;
  capPopover.setAttribute('role','dialog');
  capMoreBtn.appendChild(capPopover);

  capSearch = document.createElement('input');
  capSearch.type='search';
  capSearch.placeholder='Search capabilities…';
  capSearch.className='capSearch';
  capPopover.appendChild(capSearch);

  const capListEl = el('div','capList');
  capPopover.appendChild(capListEl);

  const capAlphabetical = Array.from(allCaps).sort((a,b)=> a.localeCompare(b));
  capAlphabetical.forEach(cap=>{
    const label = el('label','capOption');
    const input=document.createElement('input');
    input.type='checkbox';
    input.checked = selectedCaps.has(cap);
    capCheckboxes.set(cap, input);
    input.addEventListener('change',()=>{
      setCapSelected(cap, input.checked);
      afterCapSelectionChange();
    });
    const textSpan=document.createElement('span');
    textSpan.textContent=cap;
    label.appendChild(input);
    label.appendChild(textSpan);
    capOptionRows.set(cap, label);
    capListEl.appendChild(label);
  });

  const capActions = el('div','capActions');
  const clearCapsBtn=document.createElement('button');
  clearCapsBtn.type='button';
  clearCapsBtn.textContent='Clear';
  clearCapsBtn.addEventListener('click',()=>{
    if(!selectedCaps.size) return;
    const toClear = Array.from(selectedCaps);
    toClear.forEach(cap=> setCapSelected(cap, false));
    capAllBtn.classList.add('on');
    afterCapSelectionChange();
  });
  const doneCapsBtn=document.createElement('button');
  doneCapsBtn.type='button';
  doneCapsBtn.className='primary';
  doneCapsBtn.textContent='Done';
  doneCapsBtn.addEventListener('click', closeCapPopover);
  capActions.appendChild(clearCapsBtn);
  capActions.appendChild(doneCapsBtn);
  capPopover.appendChild(capActions);

  capMoreBtn.addEventListener('click', toggleCapPopover);
  capSearch.addEventListener('input',()=> filterCapOptions(capSearch.value));
  document.addEventListener('keydown', e=>{ if(e.key==='Escape') closeCapPopover(); });
  document.addEventListener('pointerdown', e=>{
    if(!capPopoverOpen) return;
    if(capPopover.contains(e.target) || capMoreBtn.contains(e.target)) return;
    closeCapPopover();
  });

  refreshActiveCapChips();
  updateCapSummary();

  // Build dynamic Layer filter chips from LAYERS derived from data
  LAYERS.forEach(l => layerBox.appendChild(makeFchip(l, 'layer')));

  custAllBtn = makeAllChip('cust'); custBox.appendChild(custAllBtn);
  Array.from(allCusts).sort((a,b)=> a.localeCompare(b)).forEach(c=> custBox.appendChild(makeFchip(c,'cust')));

  channelAllBtn = makeAllChip('channel'); channelBox.appendChild(channelAllBtn);
  Array.from(allChannels).sort((a,b)=> a.localeCompare(b)).forEach(ch=> channelBox.appendChild(makeFchip(ch,'channel')));


  const DELIVERY_ORDER = ['Product','Service','Open-source','Community','Data/Intel','Hybrid'];
  const allDeliveries = new Set();
  vendors.forEach(v=> deliveryTokens(v.delivery).forEach(d=> allDeliveries.add(d)));
  const sortedDeliveries = Array.from(allDeliveries).sort((a,b)=>{
    const ai=DELIVERY_ORDER.indexOf(a); const bi=DELIVERY_ORDER.indexOf(b);
    if(ai!==-1 || bi!==-1){ return (ai===-1? 999:ai) - (bi===-1? 999:bi); }
    return a.localeCompare(b);
  });
  deliveryAllBtn = makeAllChip('delivery'); deliveryBox.appendChild(deliveryAllBtn);
  sortedDeliveries.forEach(m=> deliveryBox.appendChild(makeFchip(m,'delivery')));

  // ===== Toolbar highlighting (group-collapsing filters) =====
  const btnAll = document.getElementById('btnAll');
  const btnPlatforms = document.getElementById('btnPlatforms');
  const btnSpanners = document.getElementById('btnSpanners');
  function syncToolbar(){
    const anyLayerFilters = selectedLayers.size;
    if (anyLayerFilters) {
      btnAll.classList.remove('active');
    } else if (mode === 'all') {
      btnAll.classList.add('active');
    }
  }

  function clearButtons(){ [btnAll,btnPlatforms,btnSpanners].forEach(b=>b.classList.remove('active')); }

  function updateGroupVisibility(){
    document.querySelectorAll('.group').forEach(group=>{
      const wall = group.querySelector('.wall');
      if(!wall) return;
      const visible = wall.querySelectorAll('.card:not([data-hidden="true"])').length;
      group.style.display = visible ? '' : 'none';
    });
  }

  function cardMatchesFilters(card){
    // Mode filter
    if(mode==='platforms' && !card.classList.contains('platform')) return false;
    if(mode==='spanners' && !card.classList.contains('spanner')) return false;
    // Layer filter
    const layers=(card.dataset.layers||'').split('|').filter(Boolean);
    if(selectedLayers.size && !intersects(selectedLayers, layers)) return false;
    // Capability filter
    const caps=(card.dataset.caps||'').split('|').filter(Boolean);
    if(!intersects(selectedCaps, caps)) return false;
    // Customer filter
    const cust=(card.dataset.customers||'').split('|').filter(Boolean);
    if(!intersects(selectedCusts, cust)) return false;
    // Channels filter
    const chans=(card.dataset.channels||'').split('|').filter(Boolean);
    if(selectedChannels.size && !intersects(selectedChannels, chans)) return false;
    // Delivery filter
    const deliveries=(card.dataset.delivery||'').split('|').filter(Boolean);
    if(selectedDeliveries.size && !intersects(selectedDeliveries, deliveries)) return false;
    return true;
  }

  // ======= Primary-aware sorting helpers =======
  function arrFromDataset(card, key){
    const v = card.dataset[key] || '';
    return v ? v.split('|').filter(Boolean) : [];
  }
  function intersectsSet(set, arr){
    if(!set.size) return false;
    for(const v of arr){ if(set.has(v)) return true; }
    return false;
  }
  function scoreCard(card){
    let s = 0;
    // Primary matches score higher than non-primary matches
    if(selectedLayers.size){
      if(selectedLayers.has(card.dataset.primaryLayer)) s += 1000;
      else if(intersectsSet(selectedLayers, arrFromDataset(card,'layers'))) s += 10;
    }
    if(selectedCaps.size){
      if(selectedCaps.has(card.dataset.primaryCategory)) s += 1000;
      else if(intersectsSet(selectedCaps, arrFromDataset(card,'caps'))) s += 10;
    }
    if(selectedCusts.size){
      if(selectedCusts.has(card.dataset.primaryCustomer)) s += 1000;
      else if(intersectsSet(selectedCusts, arrFromDataset(card,'customers'))) s += 10;
    }
    if(selectedChannels.size){
      if(selectedChannels.has(card.dataset.primaryChannel)) s += 1000;
      else if(intersectsSet(selectedChannels, arrFromDataset(card,'channels'))) s += 10;
    }
    if(selectedDeliveries.size){
      if(selectedDeliveries.has(card.dataset.primaryDelivery)) s += 1000;
      else if(intersectsSet(selectedDeliveries, arrFromDataset(card,'delivery'))) s += 10;
    }
    if(mode==='platforms' && card.classList.contains('platform')) s += 1;
    if(mode==='spanners' && card.classList.contains('spanner')) s += 1;
    return s;
  }
  function sortWall(wall){
    const cards = Array.from(wall.querySelectorAll('.card'));
    cards.sort((a,b)=>{
      const da = scoreCard(a), db = scoreCard(b);
      if(db !== da) return db - da;
      // tie-breaker: alphabetical by name
      const na = a.querySelector('h3 a')?.textContent?.trim() || '';
      const nb = b.querySelector('h3 a')?.textContent?.trim() || '';
      return na.localeCompare(nb);
    });
    cards.forEach(c=> wall.appendChild(c));
  }

  function applyFilters(){
    document.querySelectorAll('.wall').forEach(wall=>{
      wall.querySelectorAll('.card').forEach(card=>{
        const keep = cardMatchesFilters(card);
        if(keep){ card.removeAttribute('data-hidden'); card.style.display=''; }
        else { card.setAttribute('data-hidden','true'); card.style.display='none'; }
      });
      // Reorder visible cards so primaries for selected filters rise to the top
      sortWall(wall);
    });
    updateGroupVisibility();
    syncToolbar();
  }

  function showAll(){
    clearButtons();
    btnAll.classList.add('active');
    mode='all';
    // Clear selected LAYERS and their visual state
    if(selectedLayers.size){
      selectedLayers.clear();
      if(layerBox){
        layerBox.querySelectorAll('.fchip.layer').forEach(ch=> ch.classList.remove('on'));
      }
    }
    applyFilters();
  }
  function highlightPlatforms(){ clearButtons(); btnPlatforms.classList.add('active'); mode='platforms'; applyFilters(); }
  function highlightSpanners(){ clearButtons(); btnSpanners.classList.add('active'); mode='spanners'; applyFilters(); }
  btnAll.addEventListener('click', showAll);
  btnPlatforms.addEventListener('click', highlightPlatforms);
  btnSpanners.addEventListener('click', highlightSpanners);

  // default
  showAll();
  applyFilters();
  syncToolbar();
})();
</script>
</html>