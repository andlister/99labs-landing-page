<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Security & IT Landscape — Card View</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700;900&display=swap" rel="stylesheet">
  <script>
    // Initialize theme immediately to prevent flash
    try {
      const theme = localStorage.getItem('theme-preference');
      if (theme === 'light') document.documentElement.classList.add('light');
      else if (theme === 'dark') document.documentElement.classList.remove('light');
    } catch(e) {}
  </script>
  <script src="../../site-nav.js" defer></script>
  <style>
    :root{
      --bg:#0b1016;--panel:#121823;--ink:#e7eef7;--muted:#9bb0c8;--line:#2a3a50;--chip:#172233;
      --c1:#5aa9ff;--c2:#7bd389;--c3:#ffb86b;--c4:#de6fff;--c5:#ff6f91;--c6:#6ef2ff;
      --labelw: 86px;
    }
    /* Light theme overrides */
    :root.light{
      --bg:#ffffff;
      --panel:#ffffff;
      --ink:#0b1016;
      --muted:#4a5568;
      --line:#d8e1ea;
      --chip:#f3f7fb;
      --c1:#1e88e5;--c2:#2e7d32;--c3:#ef6c00;--c4:#8e24aa;--c5:#d81b60;--c6:#00838f;
      --labelw: 86px;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:'Lato', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--ink)}
    .wrap{max-width:100%;margin:16px auto;padding:0 24px}
    h1{font-size:28px;margin:12px 0 6px;font-weight:900;letter-spacing:.2px}
    h2{font-size:20px;margin:28px 0 12px;color:var(--ink);font-weight:700;letter-spacing:.2px}
    p.lead{color:var(--muted);margin:0 0 16px}

    /* Card wall */
    .wall{display:grid;grid-template-columns:repeat( auto-fill, minmax(320px, 1fr) );gap:14px}
    .card{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:16px 16px 10px}
    .card{position:relative}
    .platform{box-shadow:none}
    .toolbar{position:static;margin:8px 0 16px;display:flex;gap:8px;flex-wrap:wrap}
    .btn{background:var(--panel);color:var(--ink);border:1px solid var(--line);border-radius:999px;padding:6px 10px;font-size:12px;cursor:pointer}
    .btn.active{outline:2px solid #FFA500}

    /* Filter chip bars */
    .filters{display:flex;flex-wrap:wrap;gap:8px;margin:6px 0 16px}
    .fgroup{display:flex;align-items:center;gap:8px;flex-wrap:wrap;flex:1 1 100%}
    .capGroup{position:relative;align-items:flex-start;flex-basis:100%}
    .flabel{
      font-size:12px;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.06em;
      margin-right:6px;
      display:block;
      width:100%;
    }
    .fchip{background:var(--panel);color:var(--ink);border:1px solid var(--line);border-radius:999px;padding:6px 10px;font-size:12px;cursor:pointer}
    .fchip.on{outline:2px solid #3eb5c1}
    .fchip.on.cust{outline:2px solid #a78bfa}
    .fchip.all.on{outline:2px solid #3eb5c1}
    .fchip.all.on.cust{outline:2px solid #a78bfa}
    /* Layer filter chips (orange outline) */
    .fchip.on.layer{ outline:2px solid #FFA500 }
    .fchip.all.on.layer{ outline:2px solid #FFA500 }
    /* Delivery filter chips (blue outline) */
    .fchip.on.delivery{ outline:2px solid #5aa9ff }
    .fchip.all.on.delivery{ outline:2px solid #5aa9ff }
    /* Channels filter chips (pink outline) */
    .fchip.on.channel{ outline:2px solid #ff6f91 }
    .fchip.all.on.channel{ outline:2px solid #ff6f91 }

    .capTopRow{display:flex;flex-wrap:wrap;gap:8px;align-items:center;position:relative}
    .capActiveList{display:flex;flex-wrap:wrap;gap:8px}
    .capMoreBtn{position:relative;padding-right:28px}
    .capMoreBtn::after{content:"";position:absolute;right:10px;top:50%;width:6px;height:6px;border-right:1px solid currentColor;border-bottom:1px solid currentColor;transform:translateY(-50%) rotate(45deg);opacity:.6}
    .capMoreBtn[aria-expanded="true"]::after{transform:translateY(-20%) rotate(225deg)}

    .capPopover{position:absolute;top:calc(100% + 8px);left:0;background:var(--bg);border:1px solid var(--line);border-radius:12px;box-shadow:0 18px 36px rgba(15,23,42,0.35);padding:16px;min-width:260px;max-width:320px;max-height:340px;overflow:auto;z-index:90}
    .capPopover.hidden{display:none}
    .capPopover:focus{outline:none}
    .capSearch{width:100%;padding:8px 10px;border-radius:8px;border:1px solid var(--line);background:var(--panel);color:var(--ink);font-size:13px;margin-bottom:12px}
    .capList{display:flex;flex-direction:column;gap:6px}
    .capOption{display:flex;align-items:center;gap:8px;padding:4px 6px;border-radius:6px;font-size:12px;cursor:pointer}
    .capOption input{width:14px;height:14px;pointer-events:none}
    .capOption:hover{background:rgba(62,181,193,0.08)}
    .capActions{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-top:12px}
    .capActions button{flex:1;background:var(--panel);border:1px solid var(--line);border-radius:999px;padding:6px 10px;font-size:12px;color:var(--ink);cursor:pointer}
    .capActions button.primary{border-color:#3eb5c1}

    .card h3{margin:0 0 10px;font-size:16px}
    .card h3 a{color:inherit;text-decoration:none} .card h3 a:hover{text-decoration:underline}
    .badges{display:flex;flex-wrap:wrap;gap:6px;margin:4px 0;align-items:center}
    .b{background:var(--chip);color:var(--ink);border:1px solid var(--line);padding:4px 10px;border-radius:999px;font-size:12px;white-space:nowrap}
    .muted{color:var(--muted);font-size:13px;margin-top:12px;margin-bottom:0;padding-top:8px;border-top:none}

    /* Layer pill styling: muted orange outlines; primary bright orange, no fill */
    .layersRow .b{ background:transparent; border:2px solid rgba(255,165,0,0.50); opacity:1 }
    .layersRow .b.primaryLayer{ border:2px solid #FFA500 }
    /* Capabilities (teal) and Customers (lavender) outlines */
    .categoriesRow .b{ background:transparent; border:2px solid rgba(62,181,193,0.50); opacity:1 }
    .customersRow  .b{ background:transparent; border:2px solid rgba(167,139,250,0.50); opacity:1 }
    .modelRow .b{ background:transparent; border:2px solid rgba(90,169,255,0.50); opacity:1 }
    .channelsRow .b{ background:transparent; border:2px solid rgba(255,111,145,0.50); opacity:1 }
    .categoriesRow .b.primaryCap{ border:2px solid #3eb5c1 }
    .customersRow  .b.primaryCust{ border:2px solid #a78bfa }
    .modelRow .b.primaryDelivery{ border:2px solid #5aa9ff }
    .channelsRow .b.primaryChannel{ border:2px solid #ff6f91 }

    /* Inline labeled rows (title + pills on same line) */
    .row{display:flex;align-items:center;flex-wrap:wrap;gap:6px;margin:6px 0}
    .row .label{font-size:11px;text-transform:uppercase;letter-spacing:.06em;color:var(--muted);margin-right:2px}
    .row .badges{margin:0}
    /* Disable old pseudo-labels when using inline rows */
    .layersRow::before,.categoriesRow::before,.customersRow::before,.channelsRow::before,.modelRow::before{content:none !important}

    /* (Optional) box styles if you re-enable the grid later */
    .pillGrid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin:8px 0 6px}
    .box{border:1px solid var(--line);border-radius:10px;padding:8px;background:var(--panel)}
    .boxTitle{font-size:11px;text-transform:uppercase;letter-spacing:.06em;color:var(--muted);margin:0 0 6px}
    .subLabel{font-size:10px;color:var(--muted);margin:6px 0 4px}
    .box .badges{margin:0}

    /* Pricing & Sentiment sections */
    .meta{margin-top:12px;border-top:1px solid var(--line);padding-top:10px}
    .sectionTitle{font-size:13px;text-transform:uppercase;letter-spacing:.06em;color:var(--muted);margin:0 0 6px}
    .kv{display:grid;grid-template-columns:120px 1fr;gap:6px;margin:8px 0}
    .kv dt{font-size:13px;color:var(--muted)}
    .kv dd{margin:0;font-size:13px}
    .pill{display:inline-flex;align-items:center;border:1px solid var(--line);border-radius:999px;padding:4px 8px;font-size:12px;margin:2px 6px 2px 0;background:var(--chip);color:var(--ink)}
    .sourceLink{font-size:13px;color:var(--muted)}
    .sourceLink a{color:inherit;text-decoration:underline}
    .proscons{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px}
    .proscons .pill{opacity:.9}

    /* Compact meta with toggles */
    .meta details{border:1px solid var(--line);border-radius:10px;padding:8px;margin-top:8px;background:var(--panel)}
    .meta summary{cursor:pointer;list-style:none;display:flex;align-items:center;gap:8px}
    .meta summary::marker{display:none}
    .meta summary .arrow{
      display:inline-block;
      transform:rotate(0deg);
      transition:transform .2s ease;
      font-size:16px; /* bigger chevron */
      color:var(--muted);
      margin-right:6px;
      line-height:1;
      border:none;
      border-radius:0;
      width:auto;
      height:auto;
    }

    .meta summary .label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.06em;
      color:var(--muted);
      margin-right:6px;
      width:var(--labelw);
      display:inline-block;
    }
    .meta details[open] summary .arrow{transform:rotate(90deg)}
    .compactLine{font-size:13px;color:var(--muted)}
    .summaryLabel{font-size:11px;text-transform:uppercase;letter-spacing:.06em;color:var(--muted);margin-right:6px}
    .linkList{margin:6px 0 0;padding-left:16px}
    .linkList li{font-size:13px;margin:2px 0}

    /* Labeled chip rows (legacy layout kept in case you switch back) */
    .layersRow::before,
    .categoriesRow::before,
    .customersRow::before,
    .channelsRow::before,
    .modelRow::before{
      content:"";
      display:block;
      width:100%;
      margin:0 0 6px 0;
      font-size:10px;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.06em;
      opacity:.9;
    }
    .layersRow::before{ content:"Layers"; }
    .categoriesRow::before{ content:"Capabilities"; }
    .customersRow::before{ content:"Customers"; }
    .channelsRow::before{ content:"Channels"; }
    .modelRow::before{ content:"Delivery"; }

    /* Unified spacing (no separators) */
    .layersRow,
    .customersRow,
    .categoriesRow,
    .modelRow{
      margin-bottom:16px;
      padding-bottom:8px;
      border-bottom:none;
    }

    /* Group sections */
    .group{margin:18px 0 8px;padding-top:12px}
    .groupTitle{font-size:14px;color:var(--muted);text-transform:uppercase;letter-spacing:.08em;margin:0 0 8px}

    /* Customer/Industry grid (kept from earlier in case you use it later) */
    .grid{display:grid;grid-template-columns:260px 1fr;gap:0;border:1px solid var(--line);border-radius:10px;overflow:hidden}
    .colL,.colR{background:var(--panel);border-bottom:1px solid var(--line)}
    .colL{padding:12px 14px;font-weight:700;border-right:1px solid var(--line);display:flex;align-items:center}
    .colR{padding:12px 14px}
    .chips{display:flex;flex-wrap:wrap;gap:8px}
    .chip{display:inline-flex;align-items:center;justify-content:center;background:var(--chip);padding:6px 12px;border-radius:999px;border:1px solid var(--line);font-size:13px;white-space:nowrap}
    .last{border-bottom:none}

    @media (max-width:900px){
      .grid{grid-template-columns:1fr}
      .colL{border-right:none}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Security & IT Landscape</h1>
    <p class="lead"></p>

    <div class="toolbar">
      <div class="fgroup" id="layerFilters" style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
        <span class="flabel">Layers:</span>
        <button class="btn" id="btnAll">Show all</button>
        <button class="btn" id="btnPlatforms">All-in-one (≥4 layers)</button>
        <button class="btn" id="btnSpanners">Spanners (≥3 layers)</button>
        <!-- layer pills appended dynamically -->
      </div>
    </div>

    <div class="filters">
      <div class="fgroup" id="custFilters"><span class="flabel">Customers:</span></div>
      <div class="fgroup" id="channelFilters"><span class="flabel">Channels:</span></div>
      <div class="fgroup" id="deliveryFilters"><span class="flabel">Delivery:</span></div>
      <div class="fgroup capGroup" id="capFilters">
        <div class="flabel">Capabilities:</div>
      </div>
    </div>

    <!-- Predeclared groups (new/unknown primaryLayer groups will be created dynamically at the end) -->
    <div class="group">
      <p class="groupTitle">Identity</p>
      <div class="wall" id="wall-Identity"></div>
    </div>

    <div class="group">
      <p class="groupTitle">Device / IT Operations</p>
      <div class="wall" id="wall-Device / IT Operations"></div>
    </div>

    <div class="group">
      <p class="groupTitle">Cloud / Tenant</p>
      <div class="wall" id="wall-Cloud / Tenant"></div>
    </div>

    <div class="group">
      <p class="groupTitle">Security</p>
      <div class="wall" id="wall-Security"></div>
    </div>

    <div class="group">
      <p class="groupTitle">Security Operations</p>
      <div class="wall" id="wall-Security Operations"></div>
    </div>

    <div class="group">
      <p class="groupTitle">Compliance</p>
      <div class="wall" id="wall-Compliance"></div>
    </div>
  </div>
</body>
<script>
(async function(){
  async function loadVendors(){
    const res = await fetch('vendors.json', {cache:'no-cache'});
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  }

  let vendors;
  try{
    vendors = await loadVendors();
  }catch(err){
    console.error('Failed to load vendor data:', err);
    alert('Could not load vendor data');
    return;
  }

  // Build LAYERS dynamically from data (show exactly what's in vendors.json)
  let LAYERS = [];
  const allLayerSet = new Set();
  vendors.forEach(v => (v.layers || []).forEach(l => allLayerSet.add(l)));
  LAYERS = Array.from(allLayerSet).sort((a,b)=> a.localeCompare(b));

  // Filters state
  const selectedCaps=new Set();
  const selectedCusts=new Set();
  const selectedDeliveries=new Set();
  const selectedChannels=new Set();
  const selectedLayers=new Set();
  let mode='all'; // all | platforms | spanners

  function el(tag, cls, html){
    const e=document.createElement(tag); if(cls) e.className=cls; if(html!=null) e.innerHTML=html; return e;
  }
  function chip(text){
    const s=el('span','b'); s.textContent=text; return s;
  }

  const byText = s=> s.textContent.trim();
  function intersects(aSet, arr){ if(!aSet.size) return true; for(const v of arr){ if(aSet.has(v)) return true; } return false; }

  // Use vendors.json as source of truth without normalization
  function deliveryTokens(val){
    if(val==null || val==='') return [];
    const toArray = (input)=>{
      if(input==null || input==='') return [];
      if(Array.isArray(input)) return input;
      return [input];
    };
    const tokens=[];
    const seen=new Set();
    toArray(val).forEach(token=>{
      if(token==null) return;
      const t=String(token).trim();
      if(!t) return;
      if(seen.has(t)) return;
      seen.add(t);
      tokens.push(t);
    });
    return tokens;
  }

  function getPrimaryLayer(v){
    const L = v.layers || [];
    if(v.primaryLayer && L.includes(v.primaryLayer)) return v.primaryLayer;
    return L.length ? L[0] : null;
  }

    function buildCard(v){
      const card=el('div','card');

      // Determine primaries (fallback to first array element if explicit primary not set)
      const priLayer = getPrimaryLayer(v);
      const priCustomer = v.primaryCustomer || ((v.customers||[])[0] || null);
      const priCategory = v.primaryCategory || ((v.categories||[])[0] || null);

      const h3=el('h3'); const a=el('a'); a.href=v.url||'#'; a.target='_blank'; a.rel='noopener'; a.textContent=v.name; h3.appendChild(a); card.appendChild(h3);

      // === Inline rows: label + pills on same line ===
      function renderRow(title, className, items, primaryMatcher){
        if(!items || !items.length) return null;
        const row = el('div', `row ${className}`);
        row.appendChild(el('span','label',title));
        const wrap = el('div','badges');
        items.forEach((val,idx)=>{
          const chipEl = chip(val);
          if(typeof primaryMatcher === 'function' && primaryMatcher(val, idx)){
            // Add class based on row type
            if(className.includes('layersRow')) chipEl.classList.add('primaryLayer');
            if(className.includes('categoriesRow')) chipEl.classList.add('primaryCap');
            if(className.includes('customersRow')) chipEl.classList.add('primaryCust');
            if(className.includes('modelRow')) chipEl.classList.add('primaryDelivery');
            if(className.includes('channelsRow')) chipEl.classList.add('primaryChannel');
          }
          wrap.appendChild(chipEl);
        });
        row.appendChild(wrap);
        return row;
      }

      const L = v.layers || [];
      const priLayer_ = getPrimaryLayer(v);
      const cats = v.categories || [];
      const priCat = v.primaryCategory || cats[0] || null;
      const custs = v.customers || [];
      const priCust = v.primaryCustomer || custs[0] || null;
      const deliveries = deliveryTokens(v.delivery);
      const priDelivery = v.primaryDelivery || deliveries[0] || null;
      const channels = Array.isArray(v.channels) ? v.channels.filter(Boolean) : [];
      const priChannel = channels[0] || null;

      const rowsFrag = document.createDocumentFragment();
      const r1 = renderRow('Layers','layersRow', L, (val)=> val===priLayer_);
      const r2 = renderRow('Capabilities','categoriesRow', cats, (val)=> val===priCat);
      const r3 = renderRow('Customers','customersRow', custs, (val)=> val===priCust);
      const r4 = renderRow('Delivery','modelRow', deliveries, (val)=> val===priDelivery);
      const r5 = renderRow('Channels','channelsRow', channels, (val)=> val===priChannel);
      [r1,r2,r3,r4,r5].forEach(r=>{ if(r) rowsFrag.appendChild(r); });
      card.appendChild(rowsFrag);

      // Description
      if(v.description){ const p=el('p','muted'); p.textContent=v.description; card.appendChild(p); }

      // Pricing & Sentiment sections (compact with toggles)
      const hasPricing = v.pricing && (v.pricing.model || v.pricing.list != null || (Array.isArray(v.pricing.tiers) && v.pricing.tiers.length) || v.pricing.notes);
      const hasSentiment = v.sentiment && (v.sentiment.g2_rating != null || v.sentiment.summary || (Array.isArray(v.sentiment.pros) && v.sentiment.pros.length) || (Array.isArray(v.sentiment.cons) && v.sentiment.cons.length));

      if(hasPricing || hasSentiment){
        const meta = el('div','meta');

        if(hasPricing){
          const det = document.createElement('details');
          const sum = document.createElement('summary');
          sum.appendChild(el('span','arrow','›'));
          sum.appendChild(el('span','label','Price'));
          const currency = (v.pricing.currency || '').toUpperCase();
          const unit = v.pricing.unit || '';
          const fmtMoney = (n)=>{
            if(n==null || isNaN(Number(n))) return '';
            const val = Number(n);
            const sym = currency === 'USD' ? '$' : (currency ? currency + ' ' : '$');
            return sym + (Math.round(val*100)/100).toString();
          };
          // Compact line
          const headlineParts = [];
          if(v.pricing.model) headlineParts.push(v.pricing.model);
          const firstTier = Array.isArray(v.pricing.tiers) && v.pricing.tiers[0] ? v.pricing.tiers[0] : null;
          if(firstTier && firstTier.price!=null){ headlineParts.push(`${firstTier.name}: ${fmtMoney(firstTier.price)}`); }
          else if(v.pricing.list!=null){ headlineParts.push(`List: ${fmtMoney(v.pricing.list)}`); }
          if(unit) headlineParts.push(unit);
          const line = el('span','compactLine', headlineParts.join(' • '));
          sum.appendChild(line);
          det.appendChild(sum);

          // Expanded content
          const st = el('p','sectionTitle','Pricing');
          const dl = el('dl','kv');
          const addRow = (k,vv)=>{ const dt=el('dt',null,k); const dd=el('dd',null,vv); dl.appendChild(dt); dl.appendChild(dd); };
          if(v.pricing.model) addRow('Model', v.pricing.model + (unit?` — ${unit}`:''));
          if(v.pricing.list!=null) addRow('List', fmtMoney(v.pricing.list));
          if(Array.isArray(v.pricing.tiers) && v.pricing.tiers.length){
            const tiersWrap = document.createElement('div');
            v.pricing.tiers.forEach(t=>{
              const label = [t.name, (t.price!=null? fmtMoney(t.price): null)].filter(Boolean).join(' · ');
              const pill = el('span','pill', label || 'Tier');
              tiersWrap.appendChild(pill);
            });
            const dt=el('dt',null,'Tiers'); const dd=el('dd'); dd.appendChild(tiersWrap); dl.appendChild(dt); dl.appendChild(dd);
          }
          if(v.pricing.notes){ addRow('Notes', v.pricing.notes); }
          if(Array.isArray(v.pricing.sources) && v.pricing.sources.length){
            const list = document.createElement('ul'); list.className='linkList';
            v.pricing.sources.forEach(u=>{ const li=document.createElement('li'); const a=document.createElement('a'); a.href=u; a.target='_blank'; a.rel='noopener'; a.textContent=u; li.appendChild(a); list.appendChild(li); });
            det.appendChild(st); det.appendChild(dl); det.appendChild(list);
          } else { det.appendChild(st); det.appendChild(dl); }
          meta.appendChild(det);
        }

        if(hasSentiment){
          const det2 = document.createElement('details');
          const sum2 = document.createElement('summary');
          sum2.appendChild(el('span','arrow','›'));
          sum2.appendChild(el('span','label','Sentiment'));
          const g2line = (v.sentiment.g2_rating!=null ? `G2: ${v.sentiment.g2_rating}` : null);
          const sumline = v.sentiment.summary ? v.sentiment.summary : null;
          sum2.appendChild(el('span','compactLine', [g2line, sumline].filter(Boolean).join(' • ')));
          det2.appendChild(sum2);

          const st2 = el('p','sectionTitle','Sentiment');
          const dl2 = el('dl','kv');
          const addRow2 = (k,vv)=>{ const dt=el('dt',null,k); const dd=el('dd',null,vv); dl2.appendChild(dt); dl2.appendChild(dd); };
          if(v.sentiment.g2_rating!=null){
            const rc = v.sentiment.g2_reviews_count!=null ? ` (${v.sentiment.g2_reviews_count} reviews)` : '';
            addRow2('G2', `${v.sentiment.g2_rating}${rc}`);
          }
          if(v.sentiment.summary){ addRow2('Summary', v.sentiment.summary); }
          const pros = Array.isArray(v.sentiment.pros) ? v.sentiment.pros : [];
          const cons = Array.isArray(v.sentiment.cons) ? v.sentiment.cons : [];
          if(pros.length){ const wrap = el('div','proscons'); pros.forEach(pv=> wrap.appendChild(el('span','pill','+ ' + pv))); const dt=el('dt',null,'Pros'); const dd=el('dd'); dd.appendChild(wrap); dl2.appendChild(dt); dl2.appendChild(dd); }
          if(cons.length){ const wrap = el('div','proscons'); cons.forEach(cv=> wrap.appendChild(el('span','pill','− ' + cv))); const dt=el('dt',null,'Cons'); const dd=el('dd'); dd.appendChild(wrap); dl2.appendChild(dt); dl2.appendChild(dd); }
          if(Array.isArray(v.sentiment.sources) && v.sentiment.sources.length){
            const list = document.createElement('ul'); list.className='linkList';
            v.sentiment.sources.forEach(u=>{ const li=document.createElement('li'); const a=document.createElement('a'); a.href=u; a.target='_blank'; a.rel='noopener'; a.textContent=u; li.appendChild(a); list.appendChild(li); });
            det2.appendChild(st2); det2.appendChild(dl2); det2.appendChild(list);
          } else { det2.appendChild(st2); det2.appendChild(dl2); }
          meta.appendChild(det2);
        }

        card.appendChild(meta);
      }

      // Datasets for filters & sorting
      card.dataset.caps = (v.categories||[]).join('|');
      card.dataset.customers = (v.customers||[]).join('|');
      card.dataset.delivery = deliveries.join('|');
      card.dataset.layers = (v.layers || []).join('|');
      card.dataset.primaryLayer = priLayer || '';
      card.dataset.primaryCategory = priCategory || '';
      card.dataset.primaryCustomer = priCustomer || '';
      card.dataset.primaryDelivery = priDelivery || '';
      card.dataset.channels = channels.join('|');
      card.dataset.primaryChannel = priChannel || '';

      return card;
    }

  // Group walls by primaryLayer; create new walls dynamically for unknown values
  const walls={};
  document.querySelectorAll('[id^="wall-"]').forEach(w=>{ walls[w.id.replace('wall-','')] = w; });

  function ensureWall(title){
    if(!title) title = 'Unassigned';
    if(walls[title]) return walls[title];
    const existing = document.getElementById('wall-' + title);
    if(existing){ walls[title] = existing; return existing; }
    const wrap = document.querySelector('.wrap');
    const group = document.createElement('div');
    group.className = 'group';
    const h = document.createElement('p');
    h.className = 'groupTitle';
    h.textContent = title;
    const wall = document.createElement('div');
    wall.className = 'wall';
    wall.id = 'wall-' + title;
    group.appendChild(h);
    group.appendChild(wall);
    wrap.appendChild(group);
    walls[title] = wall;
    return wall;
  }

  vendors.forEach(v=>{
    const key = getPrimaryLayer(v) || 'Unassigned';
    const wall = ensureWall(key);
    wall.appendChild(buildCard(v));
  });

  // Mark platform/spanner by count of layer pills
  document.querySelectorAll('.card').forEach(card=>{
    const count = card.querySelectorAll('.layersRow .b').length;
    card.dataset.span = String(count);
    card.classList.toggle('platform', count>=4);
    card.classList.toggle('spanner', count>=3);
  });

  // Build unique capability, customer, delivery, channel lists
  const allCaps=new Set();
  const capCounts=new Map();
  const allCusts=new Set();
  const allChannels=new Set();
  vendors.forEach(v=>{
    (v.categories||[]).forEach(c=>{
      allCaps.add(c);
      capCounts.set(c, (capCounts.get(c) || 0) + 1);
    });
    (v.customers||[]).forEach(c=>allCusts.add(c));
    (v.channels||[]).forEach(ch=>allChannels.add(ch));
  });

  const capBox=document.getElementById('capFilters');
  const custBox=document.getElementById('custFilters');
  const channelBox=document.getElementById('channelFilters');
  const deliveryBox=document.getElementById('deliveryFilters');
  const layerBox=document.getElementById('layerFilters');
  let capAllBtn, custAllBtn, channelAllBtn, deliveryAllBtn, layerAllBtn;
  
  const capButtons=new Map();
  const capCheckboxes=new Map();
  const capOptionRows=new Map();
  const activeCapButtons=new Map();
  let capMoreBtn, capMoreLabel, capPopover, capSearch, capActiveList;
  let capPopoverOpen=false;

  function makeFchip(text, group){
    const isCust = group==='cust';
    const isDelivery = group==='delivery';
    const isLayer = group==='layer';
    const isChannel = group==='channel';
    const b=document.createElement('button');
    b.type='button';
    b.className = 'fchip' +
      (isCust ? ' cust' : '') +
      (isLayer ? ' layer' : '') +
      (isDelivery ? ' delivery' : '') +
      (isChannel ? ' channel' : '');
    b.textContent=text;
    b.addEventListener('click',()=>{
      let set, allBtn = null;
      if(isCust){ set = selectedCusts; allBtn = custAllBtn; }
      else if(isDelivery){ set = selectedDeliveries; allBtn = deliveryAllBtn; }
      else if(isLayer){ set = selectedLayers; allBtn = layerAllBtn || null; }
      else if(isChannel){ set = selectedChannels; allBtn = channelAllBtn; }
      else return;
      if(set.has(text)) set.delete(text); else set.add(text);
      b.classList.toggle('on');
      if(allBtn){
        if(set.size>0) allBtn.classList.remove('on'); else allBtn.classList.add('on');
      }
      if (isLayer) {
        mode = 'all';
        clearButtons();
      }
      applyFilters();
    });
    return b;
  }

  function makeAllChip(group){
    const isCust = group==='cust';
    const isDelivery = group==='delivery';
    const isLayer = group==='layer';
    const isChannel = group==='channel';
    const b=document.createElement('button');
    b.type='button';
    b.className =
      'fchip all on' +
      (isCust ? ' cust' : '') +
      (isLayer ? ' layer' : '') +
      (isDelivery ? ' delivery' : '') +
      (isChannel ? ' channel' : '');
    b.textContent='Show all';
    b.addEventListener('click',()=>{
      let set, box;
      if(isCust){ set = selectedCusts; box = custBox; }
      else if(isDelivery){ set = selectedDeliveries; box = deliveryBox; }
      else if(isLayer){ set = selectedLayers; box = layerBox; }
      else if(isChannel){ set = selectedChannels; box = channelBox; }
      else return;
      if(!set.size) return;
      set.clear();
      box.querySelectorAll('.fchip').forEach(x=>{ if(!x.classList.contains('all')) x.classList.remove('on'); });
      b.classList.add('on');
      applyFilters();
    });
    return b;
  }
  function makeFchip(text, group){
    const isCust = group==='cust';
    const isDelivery = group==='delivery';
    const isLayer = group==='layer';
    const isChannel = group==='channel';
    const b=document.createElement('button');
    b.type='button';
    b.className = 'fchip' +
      (isCust ? ' cust' : '') +
      (isLayer ? ' layer' : '') +
      (isDelivery ? ' delivery' : '') +
      (isChannel ? ' channel' : '');
    b.textContent=text;
    b.addEventListener('click',()=>{
      let set, allBtn = null;
      if(isCust){ set = selectedCusts; allBtn = custAllBtn; }
      else if(isDelivery){ set = selectedDeliveries; allBtn = deliveryAllBtn; }
      else if(isLayer){ set = selectedLayers; allBtn = layerAllBtn || null; }
      else if(isChannel){ set = selectedChannels; allBtn = channelAllBtn; }
      else return;
      if(set.has(text)) set.delete(text); else set.add(text);
      b.classList.toggle('on');
      if(allBtn){
        if(set.size>0) allBtn.classList.remove('on'); else allBtn.classList.add('on');
      }
      if (isLayer) {
        mode = 'all';
        clearButtons();
      }
      applyFilters();
    });
    return b;
  }

  function setCapSelected(cap, shouldSelect){
    const already = selectedCaps.has(cap);
    if(shouldSelect === already){
      const btn = capButtons.get(cap); if(btn) btn.classList.toggle('on', shouldSelect);
      const cb = capCheckboxes.get(cap); if(cb) cb.checked = shouldSelect;
      return false;
    }
    if(shouldSelect) selectedCaps.add(cap); else selectedCaps.delete(cap);
    const btn = capButtons.get(cap); if(btn) btn.classList.toggle('on', shouldSelect);
    const cb = capCheckboxes.get(cap); if(cb) cb.checked = shouldSelect;
    return true;
  }

  function refreshActiveCapChips(){
    if(!capActiveList) return;
    const extras = Array.from(selectedCaps).filter(cap=> !capButtons.has(cap));
    const keep = new Set(extras);
    activeCapButtons.forEach((btn, cap)=>{
      if(!keep.has(cap)){
        btn.remove();
        activeCapButtons.delete(cap);
      } else {
        btn.classList.add('on');
      }
    });
    extras.forEach(cap=>{
      if(activeCapButtons.has(cap)) return;
      const btn=document.createElement('button');
      btn.type='button';
      btn.className='fchip on';
      btn.textContent=cap;
      btn.title=`Remove ${cap}`;
      btn.addEventListener('click',()=>{
        setCapSelected(cap, false);
        afterCapSelectionChange();
      });
      activeCapButtons.set(cap, btn);
      capActiveList.appendChild(btn);
    });
  }

  function updateCapSummary(){
    if(!capMoreBtn) return;
    const count = selectedCaps.size;
    const label = count ? `More capabilities (${count})` : 'More capabilities';
    if(capMoreLabel) capMoreLabel.textContent = label;
    capMoreBtn.setAttribute('aria-label', count ? `${count} capabilities selected` : 'Show more capabilities');
  }

  function afterCapSelectionChange(){
    if(selectedCaps.size>0) capAllBtn.classList.remove('on');
    else capAllBtn.classList.add('on');
    refreshActiveCapChips();
    updateCapSummary();
    applyFilters();
  }

  function createCapChip(name){
    const btn=document.createElement('button');
    btn.type='button';
    btn.className='fchip';
    btn.textContent=name;
    capButtons.set(name, btn);
    btn.classList.toggle('on', selectedCaps.has(name));
    btn.addEventListener('click',()=>{
      setCapSelected(name, !selectedCaps.has(name));
      afterCapSelectionChange();
    });
    return btn;
  }

  function filterCapOptions(term){
    const query = term.trim().toLowerCase();
    capOptionRows.forEach((row, cap)=>{
      const match = !query || cap.toLowerCase().includes(query);
    });
  }

  function closeCapPopover(){
    if(!capPopoverOpen) return;
    capPopoverOpen=false;
    capPopover.classList.add('hidden');
    capMoreBtn.setAttribute('aria-expanded','false');
    capMoreBtn.focus();
  }

  function openCapPopover(){
    if(capPopoverOpen) return;
    capPopoverOpen=true;
    capPopover.classList.remove('hidden');
    capMoreBtn.setAttribute('aria-expanded','true');
    if(capSearch){
      capSearch.value='';
      filterCapOptions('');
      requestAnimationFrame(()=> capSearch.focus());
    }
  }

  function toggleCapPopover(){
    if(capPopoverOpen) closeCapPopover(); else openCapPopover();
  }

  // Populate UI with All chip, top quick list, and popover
  const capTopRow = el('div','capTopRow');
  capBox.appendChild(capTopRow);

  capAllBtn = document.createElement('button');
  capAllBtn.type='button';
  capAllBtn.className='fchip all on';
  capAllBtn.textContent='Show all';
  capAllBtn.addEventListener('click',()=>{
    if(!selectedCaps.size) return;
    const toClear = Array.from(selectedCaps);
    toClear.forEach(cap=> setCapSelected(cap, false));
    capAllBtn.classList.add('on');
    afterCapSelectionChange();
  });
  capTopRow.appendChild(capAllBtn);

  const capByFrequency = Array.from(allCaps).sort((a,b)=>{
    const diff = (capCounts.get(b) || 0) - (capCounts.get(a) || 0);
    return diff !== 0 ? diff : a.localeCompare(b);
  });
  const topCaps = capByFrequency.slice(0, 6);
  topCaps.forEach(cap=> capTopRow.appendChild(createCapChip(cap)));

  capMoreBtn = document.createElement('button');
  capMoreBtn.type='button';
  capMoreBtn.className='fchip capMoreBtn';
  capMoreLabel=document.createElement('span');
  capMoreLabel.textContent='More capabilities';
  capMoreBtn.appendChild(capMoreLabel);
  capMoreBtn.setAttribute('aria-haspopup','true');
  capMoreBtn.setAttribute('aria-expanded','false');
  capTopRow.appendChild(capMoreBtn);

  capActiveList = el('div','capActiveList');
  capTopRow.appendChild(capActiveList);

  capPopover = el('div','capPopover hidden');
  capPopover.id='capPopover';
  capPopover.tabIndex=-1;
  capPopover.setAttribute('role','dialog');
  capMoreBtn.appendChild(capPopover);

  capSearch = document.createElement('input');
  capSearch.type='search';
  capSearch.placeholder='Search capabilities…';
  capSearch.className='capSearch';
  capPopover.appendChild(capSearch);

  const capListEl = el('div','capList');
  capPopover.appendChild(capListEl);

  const capAlphabetical = Array.from(allCaps).sort((a,b)=> a.localeCompare(b));
  capAlphabetical.forEach(cap=>{
    const label = el('label','capOption');
    const input=document.createElement('input');
    input.type='checkbox';
    input.checked = selectedCaps.has(cap);
    capCheckboxes.set(cap, input);
    input.addEventListener('change',()=>{
      setCapSelected(cap, input.checked);
      afterCapSelectionChange();
    });
    const textSpan=document.createElement('span');
    textSpan.textContent=cap;
    label.appendChild(input);
    label.appendChild(textSpan);
    capOptionRows.set(cap, label);
    capListEl.appendChild(label);
  });

  const capActions = el('div','capActions');
  const clearCapsBtn=document.createElement('button');
  clearCapsBtn.type='button';
  clearCapsBtn.textContent='Clear';
  clearCapsBtn.addEventListener('click',()=>{
    if(!selectedCaps.size) return;
    const toClear = Array.from(selectedCaps);
    toClear.forEach(cap=> setCapSelected(cap, false));
    capAllBtn.classList.add('on');
    afterCapSelectionChange();
  });
  const doneCapsBtn=document.createElement('button');
  doneCapsBtn.type='button';
  doneCapsBtn.className='primary';
  doneCapsBtn.textContent='Done';
  doneCapsBtn.addEventListener('click', closeCapPopover);
  capActions.appendChild(clearCapsBtn);
  capActions.appendChild(doneCapsBtn);
  capPopover.appendChild(capActions);

  capMoreBtn.addEventListener('click', toggleCapPopover);
  capSearch.addEventListener('input',()=> filterCapOptions(capSearch.value));
  document.addEventListener('keydown', e=>{ if(e.key==='Escape') closeCapPopover(); });
  document.addEventListener('pointerdown', e=>{
    if(!capPopoverOpen) return;
    if(capPopover.contains(e.target) || capMoreBtn.contains(e.target)) return;
    closeCapPopover();
  });

  refreshActiveCapChips();
  updateCapSummary();

  // Build dynamic Layer filter chips from LAYERS derived from data
  LAYERS.forEach(l => layerBox.appendChild(makeFchip(l, 'layer')));

  custAllBtn = makeAllChip('cust'); custBox.appendChild(custAllBtn);
  Array.from(allCusts).sort((a,b)=> a.localeCompare(b)).forEach(c=> custBox.appendChild(makeFchip(c,'cust')));

  channelAllBtn = makeAllChip('channel'); channelBox.appendChild(channelAllBtn);
  Array.from(allChannels).sort((a,b)=> a.localeCompare(b)).forEach(ch=> channelBox.appendChild(makeFchip(ch,'channel')));


  const DELIVERY_ORDER = ['Product','Service','Open-source','Community','Data/Intel','Hybrid'];
  const allDeliveries = new Set();
  vendors.forEach(v=> deliveryTokens(v.delivery).forEach(d=> allDeliveries.add(d)));
  const sortedDeliveries = Array.from(allDeliveries).sort((a,b)=>{
    const ai=DELIVERY_ORDER.indexOf(a); const bi=DELIVERY_ORDER.indexOf(b);
    if(ai!==-1 || bi!==-1){ return (ai===-1? 999:ai) - (bi===-1? 999:bi); }
    return a.localeCompare(b);
  });
  deliveryAllBtn = makeAllChip('delivery'); deliveryBox.appendChild(deliveryAllBtn);
  sortedDeliveries.forEach(m=> deliveryBox.appendChild(makeFchip(m,'delivery')));

  // ===== Toolbar highlighting (group-collapsing filters) =====
  const btnAll = document.getElementById('btnAll');
  const btnPlatforms = document.getElementById('btnPlatforms');
  const btnSpanners = document.getElementById('btnSpanners');
  function syncToolbar(){
    const anyLayerFilters = selectedLayers.size;
    if (anyLayerFilters) {
      btnAll.classList.remove('active');
    } else if (mode === 'all') {
      btnAll.classList.add('active');
    }
  }

  function clearButtons(){ [btnAll,btnPlatforms,btnSpanners].forEach(b=>b.classList.remove('active')); }

  function updateGroupVisibility(){
    document.querySelectorAll('.group').forEach(group=>{
      const wall = group.querySelector('.wall');
      if(!wall) return;
      const visible = wall.querySelectorAll('.card:not([data-hidden="true"])').length;
      group.style.display = visible ? '' : 'none';
    });
  }

  function cardMatchesFilters(card){
    // Mode filter
    if(mode==='platforms' && !card.classList.contains('platform')) return false;
    if(mode==='spanners' && !card.classList.contains('spanner')) return false;
    // Layer filter
    const layers=(card.dataset.layers||'').split('|').filter(Boolean);
    if(selectedLayers.size && !intersects(selectedLayers, layers)) return false;
    // Capability filter
    const caps=(card.dataset.caps||'').split('|').filter(Boolean);
    if(!intersects(selectedCaps, caps)) return false;
    // Customer filter
    const cust=(card.dataset.customers||'').split('|').filter(Boolean);
    if(!intersects(selectedCusts, cust)) return false;
    // Channels filter
    const chans=(card.dataset.channels||'').split('|').filter(Boolean);
    if(selectedChannels.size && !intersects(selectedChannels, chans)) return false;
    // Delivery filter
    const deliveries=(card.dataset.delivery||'').split('|').filter(Boolean);
    if(selectedDeliveries.size && !intersects(selectedDeliveries, deliveries)) return false;
    return true;
  }

  // ======= Primary-aware sorting helpers =======
  function arrFromDataset(card, key){
    const v = card.dataset[key] || '';
    return v ? v.split('|').filter(Boolean) : [];
  }
  function intersectsSet(set, arr){
    if(!set.size) return false;
    for(const v of arr){ if(set.has(v)) return true; }
    return false;
  }
  function scoreCard(card){
    let s = 0;
    // Primary matches score higher than non-primary matches
    if(selectedLayers.size){
      if(selectedLayers.has(card.dataset.primaryLayer)) s += 1000;
      else if(intersectsSet(selectedLayers, arrFromDataset(card,'layers'))) s += 10;
    }
    if(selectedCaps.size){
      if(selectedCaps.has(card.dataset.primaryCategory)) s += 1000;
      else if(intersectsSet(selectedCaps, arrFromDataset(card,'caps'))) s += 10;
    }
    if(selectedCusts.size){
      if(selectedCusts.has(card.dataset.primaryCustomer)) s += 1000;
      else if(intersectsSet(selectedCusts, arrFromDataset(card,'customers'))) s += 10;
    }
    if(selectedChannels.size){
      if(selectedChannels.has(card.dataset.primaryChannel)) s += 1000;
      else if(intersectsSet(selectedChannels, arrFromDataset(card,'channels'))) s += 10;
    }
    if(selectedDeliveries.size){
      if(selectedDeliveries.has(card.dataset.primaryDelivery)) s += 1000;
      else if(intersectsSet(selectedDeliveries, arrFromDataset(card,'delivery'))) s += 10;
    }
    if(mode==='platforms' && card.classList.contains('platform')) s += 1;
    if(mode==='spanners' && card.classList.contains('spanner')) s += 1;
    return s;
  }
  function sortWall(wall){
    const cards = Array.from(wall.querySelectorAll('.card'));
    cards.sort((a,b)=>{
      const da = scoreCard(a), db = scoreCard(b);
      if(db !== da) return db - da;
      // tie-breaker: alphabetical by name
      const na = a.querySelector('h3 a')?.textContent?.trim() || '';
      const nb = b.querySelector('h3 a')?.textContent?.trim() || '';
      return na.localeCompare(nb);
    });
    cards.forEach(c=> wall.appendChild(c));
  }

  function applyFilters(){
    document.querySelectorAll('.wall').forEach(wall=>{
      wall.querySelectorAll('.card').forEach(card=>{
        const keep = cardMatchesFilters(card);
        if(keep){ card.removeAttribute('data-hidden'); card.style.display=''; }
        else { card.setAttribute('data-hidden','true'); card.style.display='none'; }
      });
      // Reorder visible cards so primaries for selected filters rise to the top
      sortWall(wall);
    });
    updateGroupVisibility();
    syncToolbar();
  }

  function showAll(){
    clearButtons();
    btnAll.classList.add('active');
    mode='all';
    // Clear selected LAYERS and their visual state
    if(selectedLayers.size){
      selectedLayers.clear();
      if(layerBox){
        layerBox.querySelectorAll('.fchip.layer').forEach(ch=> ch.classList.remove('on'));
      }
    }
    applyFilters();
  }
  function highlightPlatforms(){ clearButtons(); btnPlatforms.classList.add('active'); mode='platforms'; applyFilters(); }
  function highlightSpanners(){ clearButtons(); btnSpanners.classList.add('active'); mode='spanners'; applyFilters(); }
  btnAll.addEventListener('click', showAll);
  btnPlatforms.addEventListener('click', highlightPlatforms);
  btnSpanners.addEventListener('click', highlightSpanners);

  // default
  showAll();
  applyFilters();
  syncToolbar();
})();
</script>
</html>
